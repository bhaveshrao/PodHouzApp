{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _assertThisInitialized from \"@babel/runtime/helpers/assertThisInitialized\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nimport * as React from 'react';\nimport Animated from \"react-native-web/dist/exports/Animated\";\n\nvar AnimationContainer = function (_React$Component) {\n  _inherits(AnimationContainer, _React$Component);\n\n  var _super = _createSuper(AnimationContainer);\n\n  function AnimationContainer(props) {\n    var _this;\n\n    _classCallCheck(this, AnimationContainer);\n\n    _this = _super.call(this, props);\n\n    _defineProperty(_assertThisInitialized(_this), \"animation\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"animatedValuesByKey\", {});\n\n    _defineProperty(_assertThisInitialized(_this), \"interpolationsByKey\", {});\n\n    _defineProperty(_assertThisInitialized(_this), \"startAnimation\", function () {\n      _this.animation.start();\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"stopAnimation\", function () {\n      _this.animation.reset();\n\n      for (var key in _this.animatedValuesByKey) {\n        _this.animatedValuesByKey[key].setValue(0);\n      }\n    });\n\n    var initAnimation = props.initAnimation;\n    var animationInitializersByKey = initAnimation();\n    var animations = [];\n\n    for (var key in animationInitializersByKey) {\n      var animationInitializer = animationInitializersByKey[key];\n      var animationValue = new Animated.Value(0);\n      _this.animatedValuesByKey[key] = animationValue;\n\n      var _animationInitializer = animationInitializer(animationValue),\n          animation = _animationInitializer.animation,\n          values = _animationInitializer.values;\n\n      animations.push(animation);\n      _this.interpolationsByKey[key] = values;\n    }\n\n    if (animations.length === 1) {\n      _this.animation = animations[0];\n    } else {\n      _this.animation = Animated.parallel(animations);\n    }\n\n    return _this;\n  }\n\n  _createClass(AnimationContainer, [{\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      if (this.props.animating) {\n        this.startAnimation();\n      }\n    }\n  }, {\n    key: \"componentDidUpdate\",\n    value: function componentDidUpdate(prevProps) {\n      var animating = this.props.animating;\n\n      if (animating !== prevProps.animating) {\n        if (animating) {\n          this.startAnimation();\n        } else {\n          this.stopAnimation();\n        }\n      }\n    }\n  }, {\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      this.animation.stop();\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var children = this.props.children;\n      return children ? children(this.interpolationsByKey) : null;\n    }\n  }]);\n\n  return AnimationContainer;\n}(React.Component);\n\nexport { AnimationContainer as default };\n\n_defineProperty(AnimationContainer, \"defaultProps\", {\n  animating: true\n});","map":{"version":3,"sources":["AnimationContainer.tsx"],"names":["AnimationContainer","React","animating","constructor","initAnimation","animationInitializersByKey","animations","animationInitializer","animationValue","Animated","values","componentDidMount","componentDidUpdate","prevProps","componentWillUnmount","render","children"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,OAAO,KAAP,KAAA,MAAA,OAAA;;;IAgBe,kB;;;;;EAiBbG,4BAAW,KAAXA,EAA6B;IAAA;;IAAA;;IAC3B,0BAAA,KAAA;;IAD2B,eAAA,gCAAA,WAAA,EAAA,KAAA,CAAA,CAAA;;IAAA,eAAA,gCAAA,qBAAA,EAboB,EAapB,CAAA;;IAAA,eAAA,gCAAA,qBAAA,EANzB,EAMyB,CAAA;;IAAA,eAAA,gCAAA,gBAAA,EAyCZ,YAAM;MACrB,MAAA,SAAA,CAAA,KAAA;IA1C2B,CAAA,CAAA;;IAAA,eAAA,gCAAA,eAAA,EA6Cb,YAAM;MACpB,MAAA,SAAA,CAAA,KAAA;;MAEA,KAAK,IAAL,GAAA,IAAkB,MAAlB,mBAAA,EAA4C;QAC1C,MAAA,mBAAA,CAAA,GAAA,EAAA,QAAA,CAAA,CAAA;MACD;IAlD0B,CAAA,CAAA;;IAE3B,IAAQC,aAAR,GAAA,KAAA,CAAQA,aAAR;IAEA,IAAMC,0BAA0B,GAAGD,aAAnC,EAAA;IACA,IAAME,UAAyC,GAA/C,EAAA;;IAEA,KAAK,IAAL,GAAA,IAAA,0BAAA,EAA8C;MAC5C,IAAMC,oBAAoB,GAAGF,0BAA0B,CAAvD,GAAuD,CAAvD;MACA,IAAMG,cAAc,GAAG,IAAIC,QAAQ,CAAZ,KAAA,CAAvB,CAAuB,CAAvB;MACA,MAAA,mBAAA,CAAA,GAAA,IAAA,cAAA;;MACA,4BAA8BF,oBAAoB,CAAlD,cAAkD,CAAlD;MAAA,IAAM,SAAN,yBAAM,SAAN;MAAA,IAAmBG,MAAnB,yBAAmBA,MAAnB;;MACAJ,UAAU,CAAVA,IAAAA,CAAAA,SAAAA;MACA,MAAA,mBAAA,CAAA,GAAA,IAAA,MAAA;IACD;;IAED,IAAIA,UAAU,CAAVA,MAAAA,KAAJ,CAAA,EAA6B;MAC3B,MAAA,SAAA,GAAiBA,UAAU,CAA3B,CAA2B,CAA3B;IADF,CAAA,MAEO;MACL,MAAA,SAAA,GAAiBG,QAAQ,CAARA,QAAAA,CAAjB,UAAiBA,CAAjB;IACD;;IApB0B;EAqB5B;;;;WAEDE,6BAAoB;MAClB,IAAI,KAAA,KAAA,CAAJ,SAAA,EAA0B;QACxB,KAAA,cAAA;MACD;IACF;;;WAEDC,4BAAkB,SAAlBA,EAAwC;MACtC,IAAQV,SAAR,GAAsB,KAAtB,KAAA,CAAQA,SAAR;;MAEA,IAAIA,SAAS,KAAKW,SAAS,CAA3B,SAAA,EAAuC;QACrC,IAAA,SAAA,EAAe;UACb,KAAA,cAAA;QADF,CAAA,MAEO;UACL,KAAA,aAAA;QACD;MACF;IACF;;;WAcDC,gCAAuB;MACrB,KAAA,SAAA,CAAA,IAAA;IACD;;;WAEDC,kBAAS;MACP,IAAQC,QAAR,GAAqB,KAArB,KAAA,CAAQA,QAAR;MACA,OAAOA,QAAQ,GAAGA,QAAQ,CAAC,KAAZ,mBAAW,CAAX,GAAf,IAAA;IACD;;;;EA3EOf,KAAK,CAFA,S;;SAAA,kB;;gBAAMD,kB,kBAaG;EACpBE,SAAS,EAAE;AADS,C","sourcesContent":["import * as React from 'react'\nimport { Animated } from 'react-native'\n\ninterface AnimationNode {\n  animation: Animated.CompositeAnimation\n  values: Animated.AnimatedInterpolation[]\n}\n\nexport interface Props<T extends string> {\n  initAnimation: () => Record<T, (value: Animated.Value) => AnimationNode>\n  children: (\n    interpolationsByKey: Record<T, Animated.AnimatedInterpolation[]>\n  ) => React.ReactNode\n  animating: boolean\n}\n\nexport default class AnimationContainer<\n  T extends string\n> extends React.Component<Props<T>> {\n  animation: Animated.CompositeAnimation\n  animatedValuesByKey: Record<T, Animated.Value> = {} as Record<\n    T,\n    Animated.Value\n  >\n  interpolationsByKey: Record<\n    T,\n    Animated.AnimatedInterpolation[]\n  > = {} as Record<T, Animated.AnimatedInterpolation[]>\n\n  static defaultProps = {\n    animating: true,\n  }\n\n  constructor(props: Props<T>) {\n    super(props)\n    const { initAnimation } = props\n\n    const animationInitializersByKey = initAnimation()\n    const animations: Animated.CompositeAnimation[] = []\n\n    for (const key in animationInitializersByKey) {\n      const animationInitializer = animationInitializersByKey[key]\n      const animationValue = new Animated.Value(0)\n      this.animatedValuesByKey[key] = animationValue\n      const { animation, values } = animationInitializer(animationValue)\n      animations.push(animation)\n      this.interpolationsByKey[key] = values\n    }\n\n    if (animations.length === 1) {\n      this.animation = animations[0]\n    } else {\n      this.animation = Animated.parallel(animations)\n    }\n  }\n\n  componentDidMount() {\n    if (this.props.animating) {\n      this.startAnimation()\n    }\n  }\n\n  componentDidUpdate(prevProps: Props<T>) {\n    const { animating } = this.props\n\n    if (animating !== prevProps.animating) {\n      if (animating) {\n        this.startAnimation()\n      } else {\n        this.stopAnimation()\n      }\n    }\n  }\n\n  startAnimation = () => {\n    this.animation.start()\n  }\n\n  stopAnimation = () => {\n    this.animation.reset()\n\n    for (const key in this.animatedValuesByKey) {\n      this.animatedValuesByKey[key].setValue(0)\n    }\n  }\n\n  componentWillUnmount() {\n    this.animation.stop()\n  }\n\n  render() {\n    const { children } = this.props\n    return children ? children(this.interpolationsByKey) : null\n  }\n}\n"]},"metadata":{},"sourceType":"module"}